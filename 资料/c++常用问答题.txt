1.指针和引用的区别
    本质上的区别是，指针是一个新的变量，只是这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量，而引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，因此以达到修改变量的目的。

2.C++的内存分区
    栈区（stack）：主要存放函数参数以及局部变量，由系统自动分配释放。
    堆区（heap）：由用户通过 malloc/new 手动申请，手动释放。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
    全局/静态区：存放全局变量、静态变量；程序结束后由系统释放。
    字符串常量区：字符串常量就放在这里，程序结束后由系统释放。
    代码区：存放程序的二进制代码。

3.vector、map、multimap、unordered_map、unordered_multimap的底层数据结构，以及几种map容器如何选择？
    底层数据结构：vector基于数组，map、multimap基于红黑树，unordered_map、unordered_multimap基于哈希表。
    根据应用场景进行选择：
        map/unordered_map 不允许重复元素
        multimap/unordered_multimap 允许重复元素
        map/multimap 底层基于红黑树，元素自动有序，且插入、删除效率高
        unordered_map/unordered_multimap 底层基于哈希表，故元素无序，查找效率高。

4.内存泄漏怎么产生的？如何避免？
    内存泄漏一般是指堆内存的泄漏，也就是程序在运行过程中动态申请的内存空间不再使用后没有及时释放，导致那块内存不能被再次使用。
    更广义的内存泄漏还包括未对系统资源的及时释放，比如句柄、socket等没有使用相应的函数释放掉，导致系统资源的浪费。

5.悬空指针与野指针区别
    空指针：当所指向的对象被释放或者收回，但是没有让指针指向NULL；
    野指针：那些未初始化的指针；

6.C++类中数据成员初始化顺序？
    1.成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。
    2.如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
    3.类中const成员常量必须在构造函数初始化列表中初始化。
    4.类中static成员变量，只能在类内外初始化(同一类的所有实例共享静态成员变量)。
    初始化顺序：
        1） 基类的静态变量或全局变量
        2） 派生类的静态变量或全局变量
        3） 基类的成员变量
        4） 派生类的成员变量

7.C++vector与list区别
    1.vector数据结构
        vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。
        因此能高效的进行随机存取，时间复杂度为o(1);
        但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。
        另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。

     2.list数据结构
         list是由双向链表实现的，因此内存空间是不连续的。
         只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);
         但由于链表的特点，能高效地进行插入和删除。

8.C++中堆和栈的区别
     栈：像是装数据的桶或者箱子
             栈是大家比较熟悉的一种数据结构，它是一种具有后进先出的数据结构，也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放入比较晚的物体）。

     堆：像是一颗倒立的大树
            堆是一种经过排序的树形数据结构，每个节点都有一个值。通常我们所说的堆的数据结构是指二叉树。堆的特点是根节点的值最小（或最大），且根节点的两个树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。

9.哪些函数不能成为虚函数？
    不能被继承的函数和不能被重写的函数。

     1）普通函数：普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数。而多态体现在运行时绑定。通常通过基类指针指向子类对象实现多态。

     2）友元函数：友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

      3）构造函数：首先说下什么是构造函数，构造函数是用来初始化对象的。假如子类可以继承基类构造函数，那么子类对象的构造将使用基类的构造函数，而基类构造函数并不知道子类的有什么成员，显然是不符合语义的。从另外一个角度来讲，多态是通过基类指针指向子类对象来实现多态的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。因此构造函数不允许继承。

      4）内联成员函数：我们需要知道内联函数就是为了在代码中直接展开，减少函数调用花费的代价。也就是说内联函数是在编译时展开的。而虚函数是为了实现多态，是在运行时绑定的。因此显然内联函数和多态的特性相违背。

      5）静态成员函数：首先静态成员函数理论是可继承的。但是静态成员函数是编译时确定的，无法动态绑定，不支持多态，因此不能被重写，也就不能被声明为虚函数。、

10.this指针的理解
      通常在class定义时要用到类型变量自身时，因为这时候还不知道变量名（为了通用也不可能固定实际的变量名），就用this这样的指针来使用变量自身。

11.vector扩容原理说明
    新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；
    对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；
    初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；
    不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。
     
12.内联函数和宏定义的区别    
    1） 内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。如果内联函数的函数体过大，编译器会自动      的把这个内联函数变成普通函数。
     2）宏定义是在预处理的时候把所有的宏名用宏体来替换，简单的说就是字符串替换

13.溢出，越界，泄漏
    1.溢出：要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。
    2.越界：通常指的是数组越界
    3.泄漏：通常是指堆内存泄漏，是指使用malloc和new分配的内存没有释放造成的



    
    
